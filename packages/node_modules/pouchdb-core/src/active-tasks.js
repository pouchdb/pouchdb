// #region Type definitions

/**
 * @typedef { ActiveTaskProperties & Required<Task> } ActiveTask
 * 
 * @typedef ActiveTaskProperties
 * @property { symbol } pid Unique Process identifier
 * @property { number } updated_on Unix timestamp of last operation update
 * @property { number } progress Current percentage progress
 */

/**
 * @typedef { TaskProperties & (DatabaseCompactionTask | IndexerTask | ReplicationTask | ViewCompactionTask) } Task
 * 
 * @typedef TaskProperties
 * @property { "database_compaction" | "indexer" | "replication" | "view_compaction" } type Task type identifier
 * @property { string } database Database name
 * @property { number } total_changes Total changes to process
 * @property { number } [started_on] Task start time as unix timestamp
 * @property { number } [changes_done] Processed changes
 */

/**
 * @typedef DatabaseCompactionTask
 * @property { "database_compaction" } type Task type identifier "database_compaction"
 */

/**
 * @typedef IndexerTask
 * @property { "indexer" } type Task type identifier "indexer"
 * @property { string } design_document Design document's _id
 */

/**
 * !Note: For convenience "changes_done" and "total_changes" are also set by baseTask.
 * 
 * @typedef ReplicationTask
 * @property { "replication" } type Task type identifier "replication"
 * @property { boolean } continuous Replication runs continuously
 * @property { number } checkpointed_source_seq Sequence number of source checkpoint
 * @property { string|null } [doc_id] 
 * @property { number } [doc_write_failures] Count of failed document writes
 * @property { number } [docs_read] Count of documents
 * @property { number } [docs_written] Count of documents
 * @property { number } [missing_revisions_found]
 * @property { string } replication_id Replication id
 * @property { number } [revisions_checked] Revisions count
 * @property { string } source Replication source database name
 * @property { number } source_seq Replication sequence number on source
 * @property { string } target Replication target
 */

/**
 * @typedef ViewCompactionTask
 * @property { "view_compaction" } type Task type identifier "view_compaction"
 * @property { string } design_document Design document's _id
 */
// #endregion

/**
 * Implementation of CouchDB's _active_tasks.
 * 
 * Tasks properties are aligned with CouchDB's
 * {@link https://docs.couchdb.org/en/latest/api/server/common.html#active-tasks /_active_tasks} response reference.
 */
export default class ActiveTasks {
  constructor() {
    /** @type { Map<symbol, ActiveTask> } */
    this.tasks = new Map();
  }

  /**
   * Get a list of active tasks.
   * 
   * @returns { ActiveTask[] } array of active tasks
   */
  list() {
    return Array.from(this.tasks.values());
  }

  /**
   * Register a task.
   * 
   * @param { Task } task 
   * @returns { symbol } Process reference symbol
   * @throws { Error } if type is unknown
   */
  add(task) {
    if (typeof task.type !== "string") {
      throw new Error("type of Task.type must be string");
    }

    if (typeof task.database !== "string") {
      throw new Error("database is not a string");
    }

    if (typeof task.total_changes !== "number") {
      throw new Error("total_changes is not a number");
    }

    /** @type { ActiveTask } */
    let entry;
    if (task.type === "database_compaction") {
      entry = createDatabaseCompactionTask(task);
    }
    else if (task.type === "indexer") {
      entry = createIndexerTask(task);
    }
    else if (task.type === "replication") {
      entry = createReplicationTask(task);
    }
    else if (task.type === "view_compaction") {
      entry = createViewCompactionTask(task);
    }
    else {
      throw new Error("Task type is not supported");
    }

    const activeTask = Object.seal(entry);
    this.tasks.set(activeTask.pid, entry);
    return activeTask.pid;
  }

  /**
   * Get an active task.
   * 
   * @param { symbol } pid Process reference
   * @returns { ActiveTask | undefined } or undefined if the task is removed
   */
  get(pid) {
    return this.tasks.get(pid);
  }

  /**
   * Remove a task from active tasks list.
   * 
   * @param { symbol } pid  Process reference
   * @param { Error } [_reason] Reason of failure
   */
  /* eslint-disable no-unused-vars */
  remove(pid, _reason) {
    this.tasks.delete(pid);
  }

  /**
   * Update task's properties.
   * 
   * @param { symbol} pid Process reference
   * @param { Partial<ActiveTask> } taskUpdate 
   */
  update(pid, taskUpdate) {
    const task = this.tasks.get(pid);
    if (task && taskUpdate && typeof taskUpdate === "object") {
      Object.assign(task, Object.fromEntries(
        Object.entries(taskUpdate)
        .filter(([key]) => key !== "progress" && key !== "pid")
      ));
      task.updated_on = Date.now();
    }
  }
}

/**
 * Create the base task.
 * 
 * @template T
 * @param { T & TaskProperties } task 
 * @returns { T & Required<TaskProperties> & ActiveTaskProperties }
 */
function createBaseTask(task) {
  const type = task.type;
  const database = task.database;
  const total_changes = task.total_changes;
  const pid = Symbol(type);
  const updated_on = Date.now();

  const activeTask = Object.assign(
    {
      changes_done: 0,
      started_on: updated_on,
      progress: 0,
    },
    task,
    {
      pid,
      database,
      total_changes,
      updated_on
    }
  );

  Object.defineProperty(activeTask, "progress", {
    enumerable: true,
    get() {
      return this.changes_done / this.total_changes * 100;
    }
  });

  return activeTask;
}

/**
 * 
 * @param { TaskProperties & DatabaseCompactionTask } task 
 * @returns { ActiveTask & DatabaseCompactionTask }
 */
function createDatabaseCompactionTask(task) {
  const baseTask = createBaseTask(task);

  const activeTask = Object.defineProperties( baseTask, {
    type: {
      enumerable: true,
      value: "database_compaction"
    }
  });

  return activeTask;
}

/**
 * 
 * @param { TaskProperties & IndexerTask } task 
 * @returns { ActiveTask & IndexerTask }
 */
function createIndexerTask(task) {
  const baseTask = createBaseTask(task);

  const activeTask = Object.defineProperties( baseTask, {
    type: {
      enumerable: true,
      value: "indexer"
    },
    design_document: {
      enumerable: true,
      value: task.design_document
    }
  });

  return activeTask;
}

/**
 * 
 * @param { TaskProperties & ViewCompactionTask } task 
 * @returns { ActiveTask & ViewCompactionTask }
 */
function createViewCompactionTask(task) {
  const baseTask = createBaseTask(task);

  const activeTask = Object.defineProperties( baseTask, {
    type: {
      enumerable: true,
      value: "view_compaction"
    },
    design_document: {
      enumerable: true,
      value: task.design_document
    }
  });

  return activeTask;
}

/**
 * 
 * @param { TaskProperties & ReplicationTask } task 
 * @returns { ActiveTask & ReplicationTask }
 */
function createReplicationTask(task) {
  const baseTask = Object.assign({
    doc_id: null,
    doc_write_failures: 0,
    docs_read: 0,
    docs_written: 0,
    missing_revisions_found: 0,
    revisions_checked: 0
  }, createBaseTask(task));

  const activeTask = Object.defineProperties( baseTask, {
    type: {
      enumerable: true,
      value: "replication"
    },
    continuous: {
      enumerable: true,
      value: baseTask.continuous
    },
    checkpointed_source_seq: {
      enumerable: true,
      value: baseTask.checkpointed_source_seq
    },
    replication_id: {
      enumerable: true,
      value: baseTask.replication_id
    },
    doc_id: {
      enumerable: true,
      writable: true,
      value: baseTask.doc_id
    },
    doc_write_failures: {
      enumerable: true,
      writable: true,
      value: baseTask.doc_write_failures
    },
    docs_read: {
      enumerable: true,
      writable: true,
      value: baseTask.docs_read
    },
    docs_written: {
      enumerable: true,
      writable: true,
      value: baseTask.docs_written
    },
    missing_revisions_found: {
      enumerable: true,
      writable: true,
      value: baseTask.missing_revisions_found
    },
    revisions_checked: {
      enumerable: true,
      writable: true,
      value: baseTask.revisions_checked
    },
    source: {
      enumerable: true,
      value: baseTask.source
    },
    source_seq: {
      enumerable: true,
      value: baseTask.source_seq
    },
    target: {
      enumerable: true,
      value: baseTask.target
    }
  });

  return activeTask;
}
