import createBuiltInError from 'pouchdb-mapreduce/src/createBuiltInError';

// This helper function builds the reducers required for the builtin _stats reducer:
// sumsqr, min and max.
// It contains all the boilerplate logic for handling numbers vs. arrays.
// "sum" needs to remain a standalone function because it gets
// converted into a string somewhere else and closures aren't preserved in this case.

function createReducer({ initialValue, op, preprocess = x => x, errorName }) {
  // The returned function is the actual reducer, e.g., sum(values)
  return function(values) {
    let result = initialValue;

    if (!values) {
      return result;
    }

    for (const val of values) {
      // A. The current map value is an array
      if (Array.isArray(val)) {
        // Ensure our result is also an array. If it was a number, wrap it.
        if (typeof result === 'number') result = [result];
        else if (result === null) result = [];

        // Apply the operation element-wise
        val.forEach((item, i) => {
          if (typeof item !== 'number') throw createBuiltInError(errorName);
          const processedItem = preprocess(item);
          const current = result[i];
          // If the slot is empty, assign the item. Otherwise, apply the operation.
          result[i] = (current === undefined || current === null)
            ? processedItem
            : op(current, processedItem);
        });
      }
      // B. The current map value is a single number
      else if (typeof val === 'number') {
        const processedVal = preprocess(val);
        // If the result is already an array, operate on its first element
        if (Array.isArray(result)) {
          const current = result[0];
          result[0] = (current === undefined || current === null)
            ? processedVal
            : op(current, processedVal);
        } else { // Otherwise, the result is a number or null
          result = (result === null)
            ? processedVal
            : op(result, processedVal);
        }
      }
      // C. The value is an invalid type
      else {
        throw createBuiltInError(errorName);
      }
    }
    return result;
  };
}

export const min = createReducer({
  initialValue: null,
  op: (a, b) => Math.min(a, b),
  errorName: '_min'
});

export const max = createReducer({
  initialValue: null,
  op: (a, b) => Math.max(a, b),
  errorName: '_max'
});

export const sumsqr = createReducer({
  initialValue: 0,
  op: (a, b) => a + b,
  preprocess: x => x * x, // Special step for sumsqr
  errorName: '_sumsqr'
});