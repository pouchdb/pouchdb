'use strict';

var IDB_NULL = Number.MIN_SAFE_INTEGER;
var IDB_FALSE = Number.MIN_SAFE_INTEGER + 1;
var IDB_TRUE = Number.MIN_SAFE_INTEGER + 2;

var ALLOWABLE_SINGLE_FIELD = ['_', '$'];
var ALLOWABLE = ALLOWABLE_SINGLE_FIELD.concat(['.']);

// IndexedDB only allows valid JS names in its index paths, whereas JSON allows
// for any string at all. This cleans up valid JSON but invalid IndexedDB names
// to allow them to be indexed.
//
// This is more aggressive than it needs to be, but also simpler.
//
// There are more complete solutions available, such as using:
//    https://mothereff.in/js-variables
// As a base to properly validate, but it's very complicated and would only be
// worth looking into if act of rewriting slowed things down and we wanted to
// reduce the instances in which the `bad` var below is hit.
function sanitise(name, singleField) {
  var sanitised = '';
  var last = 0;
  var nextBad = false;

  var allowable = singleField ? ALLOWABLE_SINGLE_FIELD :  ALLOWABLE;

  for (var i = 0; i < name.length; i++) {
    var c = name[i];
    var bad = nextBad;
    nextBad = false;

    if (!bad) {
      if (!singleField && c === '\\') {
        nextBad = true;
      } else if (i === 0 && c >= '0' && c <= '9') {
        bad = true;
      } else if (!((c >= '0' && c <= '9') ||
                   (c >= 'a' && c <= 'z') ||
                   (c >= 'A' && c <= 'Z') ||
                    allowable.includes(c))) {
        bad = true;
      }
    }

    if (bad || nextBad) {
      sanitised += name.substring(last, i);
      if (bad) {
        sanitised += '_c' + c.charCodeAt(0) + '_';
      }
      last = i + 1;
    }
  }

  if (sanitised && last !== name.length) {
    sanitised += name.substring(last);
  }

  return sanitised || name;
}

//
// TODO: this does a deep clone. Don't ship this without perf tuning. Check
// performance tests to see how this affects store. NB: we do need to do some
// kind of clone becaue this is the version that will be written to .data, based
// on what is written to .revs[..], and the latter should stay unmolested, as
// the former is only needed for indexing, and so it's perfect that this rewrite
// only happens on writes, to that property
//
function rewrite(data) {
  var isArray = Array.isArray(data);
  var clone = isArray
    ? []
    : {};

  Object.keys(data).forEach(function (key) {
    var safeKey = isArray ? key : sanitise(key, true);

    if (data[key] === null) {
      clone[safeKey] = IDB_NULL;
    } else if (typeof data[key] === 'boolean') {
      clone[safeKey] = data[key] ? IDB_TRUE : IDB_FALSE;
    } else if (typeof data[key] === 'object') {
      clone[safeKey] = rewrite(data[key]);
    } else {
      clone[safeKey] = data[key];
    }
  });

  return clone;
}

export {
  IDB_NULL,
  IDB_TRUE,
  IDB_FALSE,
  rewrite,
  sanitise
};
