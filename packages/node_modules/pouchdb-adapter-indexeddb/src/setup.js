'use strict';

import { uuid } from 'pouchdb-utils';

import { META_STORE, DOC_STORE, rawIndexFields, naturalIndexName, correctIndexFields } from './util';

//
// Core PouchDB schema version. Increment this if we, as a library, want to make
// schema changes in indexeddb. See upgradePouchDbSchema()
//
var POUCHDB_IDB_VERSION = 1;

//
// Functions that manage a combinate indexeddb version, by combining the current
// time in millis that represents user migrations with a large multiplier that
// represents PouchDB system migrations.
//
// This lets us use the idb version number to both represent
// PouchDB-library-level migrations as well as "user migrations" required for
// when design documents trigger the addition or removal of native indexes.
//
// Given that Number.MAX_SAFE_INTEGER = 9007199254740991
//
// We can easily use the largest 2-3 digits and either allow:
//  - 900 system migrations up to 2198/02/18
//  - or 89 system migrations up to 5050/02/14
//
// This impl does the former. If this code still exists after 2198 someone send my
// decendents a Spacebook message congratulating them on their impressive genes.
//
// 9007199254740991 <- MAX_SAFE_INTEGER
//   10000000000000 <- 10^13
//    7199254740991 <- 2198-02-18T16:59:00.991Z
//
var versionMultiplier = Math.pow(10, 13);
function createIdbVersion() {
  return (versionMultiplier * POUCHDB_IDB_VERSION) + new Date().getTime();
}
function getPouchDbVersion(version) {
  return Math.floor(version / versionMultiplier);
}

function maintainNativeIndexes(openReq, reject) {
  var docStore = openReq.transaction.objectStore(DOC_STORE);
  var ddocsReq = docStore.getAll(IDBKeyRange.bound('_design/', '_design/\uffff'));

  ddocsReq.onsuccess = function (e) {
    var results = e.target.result;
    var existingIndexNames = Array.from(docStore.indexNames);

    var expectedIndexes = {};

    // NB: the only thing we're supporting here is the declared indexing
    // fields nothing more.
    // TODO: do we need to detect ddoc deletions here, or will they not show up at all?
    results.filter(function (r) {
      return r.deleted === 0;
    }).map(function (r) {
      return r.data;
    }).forEach(function (ddoc) {
      Object.keys(ddoc.views || {}).forEach(viewName => {
        var fields = rawIndexFields(ddoc, viewName);

        if (fields) {
          expectedIndexes[naturalIndexName(fields)] = correctIndexFields(fields);
        }
      });
    });

    var expectedIndexNames = Object.keys(expectedIndexes);

    // Delete any indexes that aren't system indexes or expected
    var systemIndexNames = ['seq'];
    existingIndexNames.forEach(function (index) {
      if (systemIndexNames.indexOf(index) === -1  && expectedIndexNames.indexOf(index) === -1) {
        docStore.deleteIndex(index);
      }
    });

    // Work out which indexes are missing and create them
    var newIndexNames = expectedIndexNames.filter(function (ei) {
      return existingIndexNames.indexOf(ei) === -1;
    });

    try {
      newIndexNames.forEach(function (indexName) {
        docStore.createIndex(indexName, expectedIndexes[indexName]);
      });
    } catch (err) {
      reject(err);
    }
  };
}

function upgradePouchDbSchema(db, pouchdbVersion) {
  if (pouchdbVersion < 1) {
    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});
    docStore.createIndex('seq', 'seq', {unique: true});

    db.createObjectStore(META_STORE, {keyPath: 'id'});
  }

  // Declare more PouchDB schema changes here
  // if (pouchdbVersion < 2) { .. }
}

function openDatabase(openDatabases, api, opts, resolve, reject) {
  // opts.storage as seen used below is deprecated and will be dropped soon.
  // We need to instead use a call to StorageManager.persist(), or something.
  // See:
  //   https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/open
  //
  // var req = opts.storage
  //   ? indexedDB.open(opts.name, {version: IDB_VERSION, storage: opts.storage})
  //   : indexedDB.open(opts.name, IDB_VERSION);

  var openReq = opts.versionchanged ?
    indexedDB.open(opts.name) :
    indexedDB.open(opts.name, createIdbVersion());

  openReq.onupgradeneeded = function (e) {
    var db = e.target.result;

    var pouchdbVersion = getPouchDbVersion(e.oldVersion);
    upgradePouchDbSchema(db, pouchdbVersion);
    maintainNativeIndexes(openReq, reject);
  };

  openReq.onblocked = function (e) {
      // AFAICT this only occurs if, after sending `onversionchange` events to
      // all other open DBs (ie in different tabs), there are still open
      // connections to the DB. In this code we should never see this because we
      // close our DBs on these events, and all DB interactions are wrapped in
      // safely re-opening the DB.
      console.error('onblocked, this should never happen', e);
  };

  openReq.onsuccess = function (e) {
    var idb = e.target.result;

    // TODO: do we need to check if we were fresh or not? One pattern
    // would be:
    //  - Open it with no stale check
    //  - Work out if we need to re-open with stale check
    //  - If we do close and re-open with version, forcing migrations
    //
    // However, the current plan is just always open presuming stale, and then
    // re-open from a onversionchange presuming not stale? This stops multiple
    // tabs getting into infinite loops, but it's also the non-optimal version
    // where it runs migrations far more than it needs to.
    //
    // Which means that either onversionchange needs to re-open the DB itself
    // (unwise I think), or it has to mark the next re-open as not stale.
    //
    // When we run a query our code in `./find.js` has to be able to detect that
    // there are changes that affect it and re-open the DB, but that would be a
    // standard close / open in this scenario.
    //
    // So we can keep this for now, but before commiting maybe look into /
    // document the idea that we might want to change it to the idea at the top
    // of this comment, which would probably be more efficient as it would
    // result in less migration time.

    idb.onabort = function (e) {
      console.error('Database has a global failure', e.target.error);
      delete openDatabases[opts.name];
      idb.close();
    };

    idb.onversionchange = function () {
      console.log('Database was made stale by being opened in another tab');
      openDatabases[opts.name].versionchanged = true;
      idb.close();
    };

    var metadata = {id: META_STORE};
    var txn = idb.transaction([META_STORE], 'readwrite');

    txn.oncomplete = function () {
      resolve({idb: idb, metadata: metadata});
    };

    var metaStore = txn.objectStore(META_STORE);
    metaStore.get(META_STORE).onsuccess = function (e) {
      metadata = e.target.result || metadata;
      var changed = false;

      if (!('doc_count' in metadata)) {
        changed = true;
        metadata.doc_count = 0;
      }

      if (!('seq' in metadata)) {
        changed = true;
        metadata.seq = 0;
      }

      if (!('db_uuid' in metadata)) {
        changed = true;
        metadata.db_uuid = uuid();
      }

      if (changed) {
        metaStore.put(metadata);
      }
    };
  };
}

export default function (openDatabases, api, opts) {
  if (!openDatabases[opts.name] || openDatabases[opts.name].versionchanged) {
    opts.versionchanged = openDatabases[opts.name] &&
                          openDatabases[opts.name].versionchanged;

    openDatabases[opts.name] = new Promise(function (resolve, reject) {
      openDatabase(openDatabases, api, opts, resolve, reject);
    });
  }

  return openDatabases[opts.name];
}
