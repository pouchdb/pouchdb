'use strict';
import { changesHandler } from 'pouchdb-utils';

import setup from './setup';

// API implementations
import info from './info';
import get from './get';
import { getAttachment, parseAttachment } from './getAttachment';
import bulkDocs from './bulkDocs';
import allDocs from './allDocs';
import changes from './changes';
import getRevisionTree from './getRevisionTree';
import doCompaction from './doCompaction';
import destroy from './destroy';
import {query, viewCleanup} from './find';

import { DOC_STORE } from './util';

var ADAPTER_NAME = 'indexeddb';

// TODO: Constructor should be capitalised
var idbChanges = new changesHandler();

// A shared list of database handles
var openDatabases = {};

function IdbPouch(dbOpts, callback) {

  var api = this;
  var metadata = {};

  // This is a wrapper function for any methods that need an
  // active database handle it will recall itself but with
  // the database handle as the first argument
  var $ = function (fun) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      setup(openDatabases, api, dbOpts).then(function (res) {
        metadata = res.metadata;
        args.unshift(res.idb);
        fun.apply(api, args);
      }).catch(function (err) {
        var last = args.unshift();
        if (typeof last === 'function') {
          last(err);
        } else {
          throw err;
        }
      });
    };
  };
  // the promise version
  var $p = function (fun) {
    return function () {
      var args = Array.prototype.slice.call(arguments);

      return new Promise(function (resolve, reject) {
        setup(openDatabases, api, dbOpts).then(function (res) {
          metadata = res.metadata;
          args.unshift(res.idb);

          return fun.apply(api, args);
        }).then(resolve)
          .catch(reject);
      });
    };
  };

  // TODO: after converting everything to this, determine if you want to instead
  // do a $txn function (like $ and $p) at this layer instead of passing the api
  // down. This would make sense if everyone always wants a transaction of the
  // same permissions each time, because then you can recontextualise the inner
  // functions as already having a transaction and get the decorate in the
  // transaction from out here.
  api._openTransactionSafely = $(function (db, stores, mode, callback) {
    try {
      callback(null, db.transaction(stores, mode));
    } catch (err) {
      if (err.name === 'InvalidStateException') {
        // Occurs when you attempt to open a transaction on a closed db. It's
        // not clear this can actually happen here, since we _just_ got a
        // correct handle from $(). Might as well check anyway, in case our
        // method of getting a fresh handle changes.
        api._openTransactionSafely(stores, mode, callback);
      } else {
        callback(err);
      }
    }
  });

  api._remote = false;
  api.type = function () { return ADAPTER_NAME; };

  api._id = $(function (_, cb) {
    cb(null, metadata.db_uuid);
  });

  api._info = $(function (_, cb) {
    return info(metadata, cb);
  });

  api._get = function (id, opts, callback) {
    // TODO: maybe default these params? Move them into an options object so you
    // can just provide 'write' sometimes?
    api._openTransactionSafely([DOC_STORE], 'readonly', function (err, txn) {
      if (err) {
        return callback(err);
      }

      get(txn, id, opts, callback);
    });
  };

  api._bulkDocs = $(function (_, req, opts, callback) {
    bulkDocs(api, req, opts, metadata, dbOpts, idbChanges, callback);
  });

  // <<-

  api._allDocs = $(function (idb, opts, cb) {
    return allDocs(idb, metadata, opts, cb);
  });

  api._getAttachment = function (docId, attachId, attachment, opts, cb) {
    // TODO: reenable and re-run tests. In theory both of these blocks should work
    // and should be useful
    //
    // if (attachment && attachment.data) {
    //   // We already have the attachment!
    //   // TODO: why are we passing the attachment to get attachment? What is going on in Pouch's brain here!?!?!
    //   return parseAttachment(attachment.data, opts, cb);
    // }

    // if (opts.ctx) {
    //   // We already have a transaction
    //   return getAttachment(opts.ctx.txn, docId, attachId, opts, cb);
    // }

    api._openTransactionSafely([DOC_STORE], 'readonly', function (err, txn) {
      if (err) {
        return cb(err);
      }

      getAttachment(txn, docId, attachId, opts, cb);
    });
  };

  api._changes = $(function (idb, opts) {
    return changes(idb, idbChanges, api, dbOpts, opts);
  });

  api._getRevisionTree = $(getRevisionTree);
  api._doCompaction = $(doCompaction);

  api._customFindAbstractMapper = {
    query: $p(query),
    viewCleanup: $p(viewCleanup)
  };

  api._destroy = function (opts, callback) {
    return destroy(dbOpts, openDatabases, idbChanges, callback);
  };

  api._close = $(function (db, cb) {
    delete openDatabases[dbOpts.name];
    db.close();
    cb();
  });

  // Closing and re-opening the DB re-generates native indexes
  api._freshen = function () {
    return new Promise(function (resolve) {
      api._close(function () {
        $(resolve)();
      });
    });
  };

  // TODO: this setTimeout seems nasty, if its needed lets
  // figure out / explain why
  setTimeout(function () {
    callback(null, api);
  });
}

// TODO: this isnt really valid permanently, just being lazy to start
IdbPouch.valid = function () {
  return true;
};

export default function (PouchDB) {
  PouchDB.adapter(ADAPTER_NAME, IdbPouch, true);
}
