'use strict';
import {
  adapterFun,
  changesHandler,
  processAttachments,
  processRevsRevsInfo,
} from 'pouchdb-utils';

import {
  collectLeaves,
  collectConflicts,
  isDeleted,
  latest as getLatest,
} from 'pouchdb-merge';

import {
  INVALID_ID,
  UNKNOWN_ERROR,
  INVALID_REV,
  createError
} from 'pouchdb-errors';

import setup from './setup';

// API implementations
import info from './info';
import get from './get';
import getAttachment from './getAttachment';
import bulkDocs from './bulkDocs';
import allDocs from './allDocs';
import changes from './changes';
import getRevisionTree from './getRevisionTree';
import doCompaction from './doCompaction';
import destroy from './destroy';
import {query, viewCleanup} from './find';
import purge from './purge';

import { DOC_STORE, idbError } from './util';

var ADAPTER_NAME = 'indexeddb';

// TODO: Constructor should be capitalised
var idbChanges = new changesHandler();

// A shared list of database handles
var openDatabases = {};

// Current implementation of _getAttachment() means we DO NOT need a database
// transaction, so the "ctx" does not need to be passed to processAttachments().
const NO_CTX_REQUIRED = null;

function IndexeddbPouch(dbOpts, callback) {

  if (dbOpts.view_adapter) {
    console.log('Please note that the indexeddb adapter manages _find indexes itself, therefore it is not using your specified view_adapter');
  }

  var api = this;
  var metadata = {};

  // Wrapper that gives you an active DB handle. You probably want $t.
  var $ = function (fun) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      setup(openDatabases, api, dbOpts).then(function (res) {
        metadata = res.metadata;
        args.unshift(res.idb);
        fun.apply(api, args);
      }).catch(function (err) {
        var last = args.pop();
        if (typeof last === 'function') {
          last(err);
        } else {
          console.error(err);
        }
      });
    };
  };
  // the promise version of $
  var $p = function (fun) {
    return function () {
      var args = Array.prototype.slice.call(arguments);

      return setup(openDatabases, api, dbOpts).then(function (res) {
        metadata = res.metadata;
        args.unshift(res.idb);

        return fun.apply(api, args);
      });
    };
  };
  // Wrapper that gives you a safe transaction handle. It's important to use
  // this instead of opening your own transaction from a db handle got from $,
  // because in the time between getting the db handle and opening the
  // transaction it may have been invalidated by index changes.
  var $t = function (fun, stores, mode) {
    stores = stores || [DOC_STORE];
    mode = mode || 'readonly';

    return function () {
      var args = Array.prototype.slice.call(arguments);
      var txn = {};
      setup(openDatabases, api, dbOpts).then(function (res) {
        metadata = res.metadata;
        txn.txn = res.idb.transaction(stores, mode);
      }).catch(function (err) {
        console.error('Failed to establish transaction safely');
        console.error(err);
        txn.error = err;
      }).then(function () {
        args.unshift(txn);
        fun.apply(api, args);
      });
    };
  };

  api._openTransactionSafely = function (stores, mode, callback) {
    $t(function (txn, callback) {
      callback(txn.error, txn.txn);
    }, stores, mode)(callback);
  };

  api._remote = false;
  api.type = function () { return ADAPTER_NAME; };

  api._id = $(function (_, cb) {
    cb(null, metadata.db_uuid);
  });

  api._info = $(function (_, cb) {
    return info(metadata, cb);
  });

  api._get = $t(get);

  api._bulkDocs = $(function (_, req, opts, callback) {
    bulkDocs(api, req, opts, metadata, dbOpts, idbChanges, callback);
  });

  api._allDocs = $t(function (txn, opts, cb) {
    allDocs(txn, metadata, opts, cb);
  });

  api._getAttachment = getAttachment;

  api._changes = $t(function (txn, opts) {
    changes(txn, idbChanges, api, dbOpts, opts);
  });

  api._getRevisionTree = $t(getRevisionTree);
  api._doCompaction = $t(doCompaction, [DOC_STORE], 'readwrite');

  api._customFindAbstractMapper = {
    query: $p(query),
    viewCleanup: $p(viewCleanup)
  };

  api._destroy = function (opts, callback) {
    return destroy(dbOpts, openDatabases, idbChanges, callback);
  };

  api._close = $(function (db, cb) {
    delete openDatabases[dbOpts.name];
    db.close();
    cb();
  });

  // Closing and re-opening the DB re-generates native indexes
  api._freshen = function () {
    return new Promise(function (resolve) {
      api._close(function () {
        $(resolve)();
      });
    });
  };

  api._purge = $t(purge, [DOC_STORE], 'readwrite');

  api.get = adapterFun('get', function (id, opts, cb) {
    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }
    opts = opts || {};
    if (typeof id !== 'string') {
      return cb(createError(INVALID_ID));
    }

    if (opts.open_revs) {
      let leaves;
      let metadata;

      const finishOpenRevs = async () => {
        var result = [];
        /* istanbul ignore if */
        if (!leaves.length) {
          return cb(null, result);
        }

        const processing = [];
        const seen = new Map();
        for (let i=leaves.length-1; i>=0; --i) {
          const leaf = leaves[i];

          const rev = opts.latest ? getLatest(leaf, metadata) : leaf;
          if (seen.has(rev)) {
            continue;
          }
          seen.set(rev);

          if (!(rev in metadata.revs)) {
            result.push({ missing: leaf });
          } else {
            const doc = metadata.revs[rev].data;
            doc._id = metadata.id;
            doc._rev = rev;

            if (isDeleted(metadata, rev)) {
              doc._deleted = true;
            }

            if (opts.revs) {
              processRevsRevsInfo(id, doc, metadata.rev_tree, opts);
            }

            processing.push(new Promise((resolve, reject) => {
              const cb = (err, res) => err ? reject(err) : resolve(res);
              processAttachments(api, metadata, doc, opts, NO_CTX_REQUIRED, cb);
            }));

            result.push({ ok: doc });
          }
        }
        try {
          await Promise.all(processing);
          cb(null, result);
        } catch (err) {
          cb(err);
        }
      };

      api._openTransactionSafely([DOC_STORE], 'readonly', function (err, txn) {
        txn.onabort = function () {
          cb(createError(UNKNOWN_ERROR, 'transaction was aborted'));
        };
        txn.ontimeout = idbError(cb);
        var req = txn.objectStore(DOC_STORE).get(id);
        req.onsuccess = function (e) {
          metadata = e.target.result;
          if (opts.open_revs === "all") {
            leaves = collectLeaves(metadata.rev_tree).map(function (leaf) {
              return leaf.rev;
            });
            finishOpenRevs();
          } else {
            if (Array.isArray(opts.open_revs)) {
              leaves = opts.open_revs;
              for (var i = 0; i < leaves.length; i++) {
                var l = leaves[i];
                // looks like it's the only thing couchdb checks
                // TODO replace with !isValidRev(l);
                if (!(typeof (l) === "string" && /^\d+-/.test(l))) {
                  return cb(createError(INVALID_REV));
                }
              }
              finishOpenRevs();
            } else {
              return cb(createError(UNKNOWN_ERROR, 'function_clause'));
            }
          }
        };
      });
      return; // open_revs does not like other options
    }

    return api._get(id, opts, (err, result) => {
      if (err) {
        err.docId = id;
        return cb(err);
      }

      var doc = result.doc;
      var metadata = result.metadata;
      var ctx = result.ctx;

      if (opts.conflicts) {
        var conflicts = collectConflicts(metadata);
        if (conflicts.length) {
          doc._conflicts = conflicts;
        }
      }

      if (isDeleted(metadata, doc._rev)) {
        doc._deleted = true;
      }

      processRevsRevsInfo(id, doc, metadata.rev_tree, opts);

      processAttachments(api, metadata, doc, opts, ctx, cb);
    });
  }).bind(api);

  // TODO: this setTimeout seems nasty, if its needed lets
  // figure out / explain why
  setTimeout(function () {
    callback(null, api);
  });
}

// TODO: this isnt really valid permanently, just being lazy to start
IndexeddbPouch.valid = function () {
  return true;
};

export default function (PouchDB) {
  PouchDB.adapter(ADAPTER_NAME, IndexeddbPouch, true);
}
