/* Copyright (c) 2012-2014 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

import { Readable } from 'stream';

function createClass(parent, init) {
  let klass = function (...args) {
    if (!(this instanceof klass)) {
      return new klass(...args);
    }
    init.apply(this, args);
  };
  klass.prototype = Object.create(parent.prototype, {
    constructor: { value: klass }
  });
  return klass;
}

class ReadStreamInternal extends Readable {
  constructor(options, makeData) {
    super({ objectMode: true, highWaterMark: options.highWaterMark });
    this._setup(options, makeData);
  }

  _setup(options, makeData) {
    super.constructor({ objectMode: true, highWaterMark: options.highWaterMark });

    // purely to keep `db` around until we're done so it's not GCed if the user doesn't keep a ref
    this._waiting = false;
    this._options = options;
    this._makeData = makeData;
  }

  setIterator(it) {
    this._iterator = it;
    /* istanbul ignore if */
    if (this._destroyed) {
      return it.end(() => { });
    }
    /* istanbul ignore if */
    if (this._waiting) {
      this._waiting = false;
      return this._read();
    }
    return this;
  }

  _cleanup(err) {
    if (this._destroyed) {
      return;
    }

    this._destroyed = true;

    /* istanbul ignore if */
    if (err && err.message !== 'iterator has ended') {
      this.emit('error', err);
    }

    /* istanbul ignore else */
    if (this._iterator) {
      this._iterator.end(() => {
        this._iterator = null;
        this.emit('close');
      });
    } else {
      this.emit('close');
    }
  }

  _destroy() {
    this._cleanup();
  }

  _read() {
    /* istanbul ignore if */
    if (this._destroyed) {
      return;
    }
    /* istanbul ignore if */
    if (!this._iterator) {
      return this._waiting = true;
    }

    this._iterator.next((err, key, value) => {
      if (err || (key === undefined && value === undefined)) {
        if (!err && !this._destroyed) {
          this.push(null);
        }
        return this._cleanup(err);
      }

      value = this._makeData(key, value);
      if (!this._destroyed) {
        this.push(value);
      }
    });
  }
}

const ReadStream = createClass(ReadStreamInternal, function (options, makeData) {
  ReadStreamInternal.prototype._setup.call(this, options, makeData);
});

export default ReadStream;
