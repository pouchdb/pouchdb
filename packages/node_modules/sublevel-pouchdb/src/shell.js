import { EventEmitter } from 'events';
import NotFoundError from './NotFoundError';

const version = "6.5.4";
const NOT_FOUND_ERROR = new NotFoundError();

function sublevel(nut, prefix, createStream, options = {}) {
  prefix = prefix || [];

  function mergeOpts(opts = {}) {
    return Object.assign({}, options, opts);
  }

  class SublevelEventEmitter extends EventEmitter {
    constructor() {
      super();
      this.isOpen = nut.isOpen;
      this.isClosed = nut.isClosed;
      this.sublevels = {};
      this.options = options;
      this.version = version;
      this.methods = {};
    }

    put(key, value, opts, cb) {
      if ('function' === typeof opts) {
        cb = opts;
        opts = {};
      }

      nut.apply(
        [{
          key,
          value,
          prefix: prefix.slice(), type: 'put'
        }],
        mergeOpts(opts),
        (err) => {
          /* istanbul ignore next */
          if (err) {
            return cb(err);
          }
          this.emit('put', key, value);
          cb(null);
        }
      );
    }

    prefix() { return prefix.slice(); }

    batch(ops, opts, cb) {
      if ('function' === typeof opts) {
        cb = opts;
        opts = {};
      }

      ops = ops.map((op) => {
        return {
          key: op.key,
          value: op.value,
          prefix: op.prefix || prefix,
          keyEncoding: op.keyEncoding,    // *
          valueEncoding: op.valueEncoding,  // * (TODO: encodings on sublevel)
          type: op.type
        };
      });

      nut.apply(ops, mergeOpts(opts), (err) => {
        /* istanbul ignore next */
        if (err) {
          return cb(err);
        }
        this.emit('batch', ops);
        cb(null);
      });
    }

    get(key, opts, cb) {
      /* istanbul ignore else */
      if ('function' === typeof opts) {
        cb = opts;
        opts = {};
      }
      nut.get(key, prefix, mergeOpts(opts), (err, value) => {
        if (err) {
          cb(NOT_FOUND_ERROR);
        } else {
          cb(null, value);
        }
      });
    }

    sublevel(name, opts) {
      if (!(name in this.sublevels)) {
        this.sublevels[name] = sublevel(nut, prefix.concat(name), createStream, mergeOpts(opts));
      }

      return this.sublevels[name];
    }

    readStream(opts) {
      return this.createReadStream(opts);
    }

    createReadStream(opts) {
      opts = mergeOpts(opts);
      opts.prefix = prefix;

      const stream = createStream(opts, nut.createDecoder(opts));
      stream.setIterator(nut.iterator(opts));

      return stream;
    }

    close(cb) {
      nut.close(cb);
    }
  }

  return new SublevelEventEmitter();
}

export default sublevel;
